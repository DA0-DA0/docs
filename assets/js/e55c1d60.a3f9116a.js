"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4395],{1527:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var i=n(5893),a=n(1151);const o={sidebar_position:4},r="Limitation",s={id:"dao-management/authz/limitation",title:"Limitation",description:"While powerful conceptually, the [Authz SDK",source:"@site/docs/dao-management/authz/limitation.md",sourceDirName:"dao-management/authz",slug:"/dao-management/authz/limitation",permalink:"/dao-management/authz/limitation",draft:!1,unlisted:!1,editUrl:"https://github.com/DA0-DA0/docs/tree/main/docs/dao-management/authz/limitation.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Execute via Authorization",permalink:"/dao-management/authz/execute"},next:{title:"Cross-chain support",permalink:"/dao-management/cross-chain"}},h={},l=[{value:"Problem",id:"problem",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"limitation",children:"Limitation"}),"\n",(0,i.jsxs)(t.p,{children:["While powerful conceptually, the ",(0,i.jsx)(t.a,{href:"https://docs.cosmos.network/main/build/modules/authz",children:"Authz SDK\nmodule"})," suffers from one\nprimary drawback that unfortunately makes it quite limited in application and in\nsome cases, often experienced by DAOs, entirely useless. The issue has been\nraised ",(0,i.jsx)(t.a,{href:"https://github.com/cosmos/cosmos-sdk/issues/18567",children:"here"}),", but the\nmaintainers at the time were unable to grasp the importance of fixing it enough\nto prioritize it, and it remains unfixed."]}),"\n",(0,i.jsx)(t.h2,{id:"problem",children:"Problem"}),"\n",(0,i.jsxs)(t.p,{children:["The problem lies in the fact that only one authorization can exist for the\ntriple ",(0,i.jsx)(t.code,{children:"(granter, grantee, type)"}),", where ",(0,i.jsx)(t.code,{children:"type"})," is the type URL of an\nauthorization. Different SDK modules define their own authorization types: the\nauthz module itself defines one\n(",(0,i.jsx)(t.a,{href:"https://docs.cosmos.network/main/build/modules/authz#genericauthorization",children:(0,i.jsx)(t.code,{children:"GenericAuthorization"})}),"),\nthe wasm module defines three (",(0,i.jsx)(t.code,{children:"StoreCodeAuthorization"}),",\n",(0,i.jsx)(t.code,{children:"ContractMigrationAuthorization"}),", and ",(0,i.jsx)(t.code,{children:"ContractExecutionAuthorization"}),"), etc."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"GenericAuthorization"})," grants a grantee unrestricted permission to execute a\nspecific message on behalf of the granter (e.g. stake tokens, undelegate tokens,\nupload contracts, etc.). While this is very powerful, the granter can only\nchoose one message to allow a grantee to perform, preventing more complex\nsituations where an account (or DAO) wishes to allow another account to act on\nbehalf of them in many ways."]}),"\n",(0,i.jsxs)(t.p,{children:["The three authorizations in the wasm module mentioned before attempt to\nworkaround this issue with an internal pattern where a single\n",(0,i.jsx)(t.code,{children:"ContractExecutionAuthorization"})," can contain a list of one or more\n",(0,i.jsx)(t.code,{children:"ContractGrant"}),"s, so a granter can effectively authorize a specific grantee to\nperform many executions on different contracts. This is certainly an\nimprovement, but it yields two more problems:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["The less serious one is that since the list of ",(0,i.jsx)(t.code,{children:"ContractGrant"}),"s in the\nauthorization is non-paginated, there is some limit to the number that can be\ncreated\u2014though it is probably pretty large."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"The more serious issue is that a developer must include all existing grants\nwhen adding a new grant. This means that if an app wants to create a contract\nauthorization between a granter and grantee, it must first query for existing\ngrants between them to prevent overriding another app's grants or even other\ngrants that exist within the same app. This is inefficient, and while\ntechnically possible, developers are not always that careful, nor should they\nbe expected to be; a developer's ability and incentive to discover that they\nare breaking another app and resolve the issue is probably quite low, and an\napp should not have to rely on other apps not accidentally breaking their\napp."}),"\n",(0,i.jsx)(t.p,{children:"Taking it a step further, proposals are created separately from when they are\nexecuted. If a proposal must include all existing grants, but the grants\nchange in the middle of its voting period, executing that proposal will now\noverride any changes that were made after it was published. Ideally,\nproposals operate incrementally: they should be able to insert a specific\ngrant or delete an existing grant without needing to know about the rest of\nthem."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Clearly, there is recognition that authz should function more as a mutable list\nof many authorizations, and since each module defines its own authorization\ntypes, this is possible to an extent. But for it to be maximally flexible and\nfuture-proof, this incremental multi-authorization functionality needs to be\nimplemented at the top, within the authz module, not individually by modules in\ntheir authorization types. It would be a nightmare for each module to come up\nwith its own system for supporting simultaneous authorization types, which is\nwhat's already happening."})]})}function d(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>r});var i=n(7294);const a={},o=i.createContext(a);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);